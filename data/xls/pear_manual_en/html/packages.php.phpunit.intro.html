<HTML
><HEAD
><TITLE
>Tutorial</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="PEAR Manual"
HREF="index.html"><LINK
REL="UP"
TITLE="PHPUnit"
HREF="package.php.phpunit.html"><LINK
REL="PREVIOUS"
TITLE="PHPUnit"
HREF="package.php.phpunit.html"><LINK
REL="NEXT"
TITLE="PHPUnit::run()"
HREF="package.php.phpunit.run.html"><META
HTTP-EQUIV="Content-type"
CONTENT="text/html; charset=ISO-8859-1"></HEAD
><BODY
CLASS="refentry"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PEAR Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="package.php.phpunit.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="package.php.phpunit.run.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="packages.php.phpunit.intro">Tutorial</H1
><DIV
CLASS="refnamediv"
><A
NAME="AEN93208"
></A
>Tutorial&nbsp;--&nbsp;
     A short tutorial about PHPUnit
    </DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN93211"
></A
><H2
>A short introduction to the test framework</H2
><P
>&#13;     <B
CLASS="classname"
>PHPUnit</B
> provides a simple
    framework for creating a test suite to
    automate testing of functions and classes.
    PHPUnit is inspired by
    <A
HREF="http://www.junit.org/"
TARGET="_top"
>JUnit</A
> which was created by
    Kent Beck and Erich Gamma as a tool for <A
HREF="http://xprogramming.com/"
TARGET="_top"
>&#13;    eXtreme Programming</A
>. One of the rules of XP
    is to test small software components as often and early
    as possible, this way you will not have to fix bugs and errors in the API
    while setting up and testing larger applications which depend on the class.
    While unit testing is one of the fundimental rules in XP, you don't have
    to switch to XP to benefit from PHPUnit. PHPUnit stands alone as a good 
    tool for testing classes or a set of functions and will ease your
    development cycle and help you to avoid endless debug sessions.
    </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="packages.php.phpunit.intro.workroutine"
></A
><H2
>Work routine</H2
><P
>&#13;    Normally, you would write a class, do some unsystematic tests
    using <B
CLASS="function"
>echo()</B
> or <B
CLASS="function"
>var_dump()</B
>.
    After this, you use the class in your application and hope everything
    is ok.
    To benefit from PHPUnit you should rethink the flow. The best way is
    to do this:
    <P
></P
><UL
><LI
><P
>1. design your class/API</P
></LI
><LI
><P
>2. create a test suite</P
></LI
><LI
><P
>3. implement the class/API</P
></LI
><LI
><P
>4. run the test suite</P
></LI
><LI
><P
>5. fix failures or errors and go to #4 again</P
></LI
></UL
>
    It may seem that this will require a lot of time, but this impression is
    wrong. Creating the test suite using PHPUnit needs only a few minutes
    and running the test suite only seconds.
   </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="packages.php.phpunit.intro.design"
></A
><H2
>Design a class</H2
><P
>&#13;    Let's start with a small example: a string class. First we create
    a bunch of functions declarations to work on a string:
    <TABLE
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
BORDER="0"
BGCOLOR="#EEEEEE"
><TR
><TD
><PRE
CLASS="php"
>---- string.php ----

&#60;?php
class String
{
    //contains the internal data
    var $data;

    // constructor
    function String($data) {
        $this-&#62;data = $data;
    }

    // creates a deep copy of the string object
    function copy() {
    }

    // adds another string object to this class
    function add($string) {
    }

    // returns the formated string
    function toString($format) {
    }
}
?&#62;</PRE
></TD
></TR
></TABLE
>
   </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="packages.php.phpunit.intro.testsuite"
></A
><H2
>Creating test suite</H2
><P
>&#13;    Now we can create a test suite, which checks every
    function of your string class. A test suite is normal
    PHP class inherited from <B
CLASS="classname"
>PHPUnit_TestCase
    </B
> containing test functions,
    identified by a leading 'test' in the function name.
    In the test function an expected value has to be compared
    with the result of the function to test.
    The result of this compare must delegate to a function
    of the <B
CLASS="function"
>assert*()</B
>-family, which decides
    if a function passes or fails the test.
    <TABLE
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
BORDER="0"
BGCOLOR="#EEEEEE"
><TR
><TD
><PRE
CLASS="php"
>---- testcase.php ----

&#60;?php

require_once 'string.php';
require_once 'PHPUnit.php';

class StringTest extends PHPUnit_TestCase
{
    // contains the object handle of the string class
    var $abc;

    // constructor of the test suite
    function StringTest($name) {
       $this-&#62;PHPUnit_TestCase($name);
    }

    // called before the test functions will be executed
    // this function is defined in PHPUnit_TestCase and overwritten
    // here
    function setUp() {
        // create a new instance of String with the
        // string 'abc'
        $this-&#62;abc = new String("abc");
    }

    // called after the test functions are executed
    // this function is defined in PHPUnit_TestCase and overwritten
    // here
    function tearDown() {
        // delete your instance
        unset($this-&#62;abc);
    }

    // test the toString function
    function testToString() {
        $result = $this-&#62;abc-&#62;toString('contains %s');
        $expected = 'contains abc';
        $this-&#62;assertTrue($result == $expected);
    }

    // test the copy function
    function testCopy() {
      $abc2 = $this-&#62;abc-&#62;copy();
      $this-&#62;assertEquals($abc2, $this-&#62;abc);
    }

    // test the add function
    function testAdd() {
        $abc2 = new String('123');
        $this-&#62;abc-&#62;add($abc2);
        $result = $this-&#62;abc-&#62;toString("%s");
        $expected = "abc123";
        $this-&#62;assertTrue($result == $expected);
    }
  }
?&#62;</PRE
></TD
></TR
></TABLE
>
   </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="packages.php.phpunit.intro.firstrun"
></A
><H2
>The first test run</H2
><P
>&#13;    Now, we can run a first test. Make sure that all the paths are correct and
    then execute this PHP program.
    <TABLE
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
BORDER="0"
BGCOLOR="#EEEEEE"
><TR
><TD
><PRE
CLASS="php"
>---- stringtest.php ----

&#60;?php

require_once 'testcase.php';
require_once 'PHPUnit.php';

$suite  = new PHPUnit_TestSuite("StringTest");
$result = PHPUnit::run($suite);

echo $result -&#62; toString();
?&#62;</PRE
></TD
></TR
></TABLE
>
   </P
><P
>&#13;    If you call this script from the commandline, you will get
    the following output:
    <TABLE
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
BORDER="0"
BGCOLOR="#EEEEEE"
><TR
><TD
><PRE
CLASS="programlisting"
>TestCase stringtest-&#62;testtostring() failed: expected true, actual false
TestCase stringtest-&#62;testcopy() failed: expected , actual Object
TestCase stringtest-&#62;testadd() failed: expected true, actual false</PRE
></TD
></TR
></TABLE
>
    Every function fails the test, because your string functions
    didn't returned what we defined as the expected value.
   </P
><P
>&#13;    If you want to call the script through your browser, you have to put
    the script in a correct html page and call <B
CLASS="function"
>$result-&#62;toHTML
    ()</B
> instead of <B
CLASS="function"
>$result-&#62;toString()</B
>.
   </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="packages.php.phpunit.intro.implement"
></A
><H2
>Implementation</H2
><P
>&#13;    Ok, let's start with implementation of the our string class.
    <TABLE
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
BORDER="0"
BGCOLOR="#EEEEEE"
><TR
><TD
><PRE
CLASS="php"
>---- string.php ----

&#60;?php
class String
{
    //contains the internal data
    var $data;

    // constructor
    function String($data) {
        $this-&#62;data = $data;
    }

    // creates a deep copy of the string object
    function copy() {
        $ret = new String($this-&#62;data);
        return $ret;
    }

    // adds another string object to this class
    function add($string) {
        $this-&#62;data = $this-&#62;data.$string-&#62;toString("%ss");
    }

    // returns the formated string
    function toString($format) {
        $ret = sprintf($format, $this-&#62;data);
        return $ret;
    }
}
?&#62;</PRE
></TD
></TR
></TABLE
>
   </P
><P
>&#13;    The implementation is complete and we can run the test again:
    <TABLE
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
BORDER="0"
BGCOLOR="#EEEEEE"
><TR
><TD
><PRE
CLASS="programlisting"
>~&#62; <B
CLASS="command"
>php -f stringtest.php</B
>
TestCase stringtest-&#62;testtostring() passed
TestCase stringtest-&#62;testcopy() passed
TestCase stringtest-&#62;testadd() failed: expected true, actual false</PRE
></TD
></TR
></TABLE
>
    D'oh! the last test failed! We made a typing mistake. Change
    line 16 in <TT
CLASS="filename"
>string.php</TT
> to
    <TABLE
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
BORDER="0"
BGCOLOR="#EEEEEE"
><TR
><TD
><PRE
CLASS="php"
>$this-&#62;data = $this-&#62;data.$string-&#62;toString("%s");</PRE
></TD
></TR
></TABLE
>
    and run the test again:
    <TABLE
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
BORDER="0"
BGCOLOR="#EEEEEE"
><TR
><TD
><PRE
CLASS="programlisting"
>~&#62; <B
CLASS="command"
>php -f stringtest.php</B
>
TestCase stringtest-&#62;testtostring() passed
TestCase stringtest-&#62;testcopy() passed
TestCase stringtest-&#62;testadd() passed</PRE
></TD
></TR
></TABLE
>
    Everything is now OK!
   </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="packages.php.phpunit.intro.conclusion"
></A
><H2
>Conclusion</H2
><P
>&#13;    Does it seem like a lot of work for testing three simple
    functions? Don't forget, this is a small example.
    Think about bigger, more complex API's like database
    abstraction or basket classes in a shop application.
    PHPUnit is an excellent tool to detect errors in the
    implementation of your class. 
   </P
><P
>&#13;    Often you will want to reimplement or refactor a large class which is
    used in several different applications. Without a test suite the
    likeliness of you breaking something in one of the applications that
    depends on your class is very high. Thanks to unit tests, you can create
    a test suite for your class, and then reimplement your class with the 
    security of knowing that as long as the new class passes the tests,
    applications that depend on the class will work.
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="package.php.phpunit.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="package.php.phpunit.run.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>PHPUnit</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="package.php.phpunit.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>PHPUnit::run()</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>